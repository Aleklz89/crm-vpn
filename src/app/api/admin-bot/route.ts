import { Bot, InlineKeyboard, webhookCallback, Context } from 'grammy';
import { PrismaClient, ArbitrationStatus } from '@prisma/client';

const userBot = new Bot(process.env.TELEGRAM_USER_BOT_TOKEN!);
const supportBot = new Bot(process.env.TELEGRAM_SUPPORT_BOT_TOKEN!);
const adminBot = new Bot(process.env.TELEGRAM_ADMIN_BOT_TOKEN!);

const prisma = new PrismaClient();

const moderatorState: { [moderatorId: number]: { state: string, targetId?: string } } = {};

const translations = {
  en: {
    welcome: "üëã Welcome, now you have moderator privileges.",
    invalid_link: "The link is invalid or has already been used.",
    moderator_bot: "üëã This is a bot for moderators!",
    command_error: "Error: Could not process the command. Please try again.",
    user_id_prompt: "Enter the user ID",
    assistant_id_prompt: "Enter the assistant ID",
    id_invalid: "The ID must be 9 digits. Please try again.",
    message_prompt: "Write your message.",
    message_sent: "Message sent successfully.",
    message_send_error: "Error sending the message. Please check the ID.",
    arbitration_list: "List of current arbitrations.",
    unknown_command: "I don't understand you.",
    message_user: "Message to user",
    message_assistant: "Message to assistant",
    menu: "Main Menu",
  },
  ru: {
    welcome: "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, —Ç–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å –ø–æ–ª–Ω–æ–º–æ—á–∏—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞.",
    invalid_link: "–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞.",
    moderator_bot: "üëã –≠—Ç–æ –±–æ—Ç –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤!",
    command_error: "–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ–º–∞–Ω–¥—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
    user_id_prompt: "–í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
    assistant_id_prompt: "–í–≤–µ–¥–∏—Ç–µ ID –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞",
    id_invalid: "ID –¥–æ–ª–∂–µ–Ω —Å–æ—Å—Ç–æ—è—Ç—å –∏–∑ 9 —Ü–∏—Ñ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
    message_prompt: "–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.",
    message_sent: "–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.",
    message_send_error: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.",
    arbitration_list: "–°–ø–∏—Å–æ–∫ —Ç–µ–∫—É—â–∏—Ö –∞—Ä–±–∏—Ç—Ä–∞–∂–µ–π.",
    unknown_command: "–Ø –≤–∞—Å –Ω–µ –ø–æ–Ω–∏–º–∞—é.",
    message_user: "–°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é",
    message_assistant: "–°–æ–æ–±—â–µ–Ω–∏–µ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É",
    menu: "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
  },
};

function getTranslation(lang: 'ru' | 'en', key: keyof typeof translations['en']): string {
  return translations[lang][key] || translations['en'][key];
}

function detectUserLanguage(ctx: Context): 'ru' | 'en' {
  const langCode = ctx.from?.language_code;
  return langCode === 'ru' ? 'ru' : 'en';
}

adminBot.command('menu', async (ctx) => {
  const lang = detectUserLanguage(ctx);

  if (ctx.from?.id) {
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ lastActiveAt –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
    await prisma.moderator.update({
      where: { id: BigInt(ctx.from.id) },
      data: { lastActiveAt: new Date() },
    });

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º
    const moderator = await prisma.moderator.findFirst({
      where: { id: BigInt(ctx.from.id) },
    });

    if (moderator) {
      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
      await showModeratorMenu(ctx, lang);
    } else {
      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä, –≤—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
      await ctx.reply(getTranslation(lang, 'command_error'));
    }
  } else {
    await ctx.reply(getTranslation(lang, 'command_error'));
  }
});



adminBot.command('start', async (ctx) => {
  const lang = detectUserLanguage(ctx);

  if (ctx.from?.id) {
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ lastActiveAt –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
    await prisma.moderator.update({
      where: { id: BigInt(ctx.from.id) },
      data: { lastActiveAt: new Date() },
    });

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è —á–µ—Ä–µ–∑ —Ç–æ–∫–µ–Ω
    if (ctx.message?.text) {
      const args = ctx.message.text.split(' ');
      if (args.length > 1) {
        const inviteToken = args[1].replace('invite_', '');

        // –ò—â–µ–º —Ç–æ–∫–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü–µ Invitation
        const invitation = await prisma.invitation.findFirst({
          where: {
            token: inviteToken,
            used: false, // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –µ—â—ë –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω
            role: 'moderator', // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —ç—Ç–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
          },
        });

        if (invitation) {
          if (!invitation.login) {
            return new Response(JSON.stringify({ message: '–õ–æ–≥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–∏' }), {
              status: 400,
            });
          }

          // –ü–µ—Ä–µ–Ω–æ—Å–∏–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã Invitation –≤ —Ç–∞–±–ª–∏—Ü—É Moderator
          await prisma.moderator.create({
            data: {
              login: invitation.login, // –õ–æ–≥–∏–Ω –∏–∑ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
              password: invitation.password || 'defaultPassword', // –ü–∞—Ä–æ–ª—å –∏–∑ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –∏–ª–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π
              id: BigInt(ctx.from.id), // Telegram ID –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
            },
          });

          // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–æ–µ
          await prisma.invitation.update({
            where: { id: invitation.id },
            data: { used: true },
          });

          // –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –º–µ–Ω—é –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
          await ctx.reply(getTranslation(lang, 'welcome'));
          await showModeratorMenu(ctx, lang);
        } else {
          await ctx.reply(getTranslation(lang, 'invalid_link'));
        }
      } else {
        await ctx.reply(getTranslation(lang, 'moderator_bot'));
      }
    } else {
      await ctx.reply(getTranslation(lang, 'command_error'));
    }
  } else {
    await ctx.reply(getTranslation(lang, 'command_error'));
  }
});


async function showModeratorMenu(ctx: Context, lang: 'ru' | 'en') {
  const keyboard = new InlineKeyboard()
    .text('üí¨ ' + getTranslation(lang, 'message_user'), 'message_user')
    .row()
    .text('üë®‚Äçüíª ' + getTranslation(lang, 'message_assistant'), 'message_assistant')
    .row()
    .text('‚öñÔ∏è ' + getTranslation(lang, 'arbitration_list'), 'current_arbitrations');

  await ctx.reply(getTranslation(lang, 'menu'), { reply_markup: keyboard });
}

async function sendMessageToUser(chatId: string, text: string) {
  const botToken = process.env.TELEGRAM_USER_BOT_TOKEN;
  if (!botToken) {
    console.error('–û—à–∏–±–∫–∞: TELEGRAM_USER_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
    return;
  }

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

  try {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: chatId, text }),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é:', error);
  }
}

async function sendMessageToAssistant(chatId: string, text: string) {
  const botToken = process.env.TELEGRAM_SUPPORT_BOT_TOKEN;
  if (!botToken) {
    console.error('–û—à–∏–±–∫–∞: TELEGRAM_SUPPORT_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
    return;
  }

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

  try {
    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: chatId, text }),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É:', error);
  }
}


adminBot.callbackQuery('message_user', async (ctx) => {
  const lang = detectUserLanguage(ctx);
  await ctx.answerCallbackQuery();
  moderatorState[ctx.from.id] = { state: 'awaiting_user_id' };
  await ctx.reply(getTranslation(lang, 'user_id_prompt'));
});

adminBot.callbackQuery('message_assistant', async (ctx) => {
  const lang = detectUserLanguage(ctx);
  await ctx.answerCallbackQuery();
  moderatorState[ctx.from.id] = { state: 'awaiting_assistant_id' };
  await ctx.reply(getTranslation(lang, 'assistant_id_prompt'));
});

adminBot.on('callback_query:data', async (ctx) => {
  const data = ctx.callbackQuery.data;

  if (data && data.startsWith('review_')) {
    await ctx.answerCallbackQuery(); // Acknowledge the callback

    const arbitrationId = BigInt(data.split('_')[1]);
    const moderatorTelegramId = BigInt(ctx.from?.id || 0);

    if (!moderatorTelegramId) {
      await ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –≤–∞—à –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä Telegram.');
      return;
    }

    try {
      // Update the arbitration record to assign the moderator and set status to IN_PROGRESS
      const arbitration = await prisma.arbitration.update({
        where: { id: arbitrationId },
        data: {
          moderatorId: moderatorTelegramId,
          status: ArbitrationStatus.IN_PROGRESS,
        },
        include: {
          user: true,
          assistant: true,
        },
      });

      // Send messages to the moderator, user, and assistant
      await ctx.reply('–í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –æ–±—Å—É–∂–¥–µ–Ω–∏—é, –æ–∂–∏–¥–∞–π—Ç–µ –ø–æ–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –æ–ø–∏—à—É—Ç –ø—Ä–æ–±–ª–µ–º—É.');

      await sendMessageToUser(
        arbitration.userId.toString(),
        '–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –æ–±—Å—É–∂–¥–µ–Ω–∏—é. –û–ø–∏—à–∏—Ç–µ —Å–≤–æ—é –ø—Ä–æ–±–ª–µ–º—É.'
      );

      await sendMessageToAssistant(
        arbitration.assistantId.toString(),
        '–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –æ–±—Å—É–∂–¥–µ–Ω–∏—é. –û–ø–∏—à–∏—Ç–µ —Å–≤–æ—é –ø—Ä–æ–±–ª–µ–º—É.'
      );

    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞:', error);
      await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞.');
    }
  }
});

adminBot.on('message:text', async (ctx) => {
  const lang = detectUserLanguage(ctx);
  const modId = ctx.from?.id;
  if (!modId) {
    await ctx.reply(getTranslation(lang, 'command_error'));
    return;
  }

  const currentState = moderatorState[modId]?.state;

  if (!currentState) {
    await ctx.reply(getTranslation(lang, 'unknown_command'));
    return;
  }

  if (currentState === 'awaiting_user_id' || currentState === 'awaiting_assistant_id') {
    const id = ctx.message.text;

    // –ò–∑–º–µ–Ω—è–µ–º —Ä–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ ID –¥–ª–∏–Ω–æ–π –æ—Ç 9 –¥–æ 10 —Ü–∏—Ñ—Ä
    if (!/^\d{9,10}$/.test(id)) {
      await ctx.reply(getTranslation(lang, 'id_invalid'));
      return;
    }

    moderatorState[modId].targetId = id;

    if (currentState === 'awaiting_user_id') {
      moderatorState[modId].state = 'awaiting_message_user';
    } else {
      moderatorState[modId].state = 'awaiting_message_assistant';
    }

    await ctx.reply(getTranslation(lang, 'message_prompt'));
  } else if (currentState === 'awaiting_message_user' || currentState === 'awaiting_message_assistant') {
    const targetId = moderatorState[modId]?.targetId;

    if (targetId) {
      const targetMessage = `–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞:\n\n${ctx.message.text}`;
      try {
        if (currentState === 'awaiting_message_user') {
          await userBot.api.sendMessage(Number(targetId), targetMessage);
        } else if (currentState === 'awaiting_message_assistant') {
          await supportBot.api.sendMessage(Number(targetId), targetMessage);
        }
        await ctx.reply(getTranslation(lang, 'message_sent'));
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
        await ctx.reply(getTranslation(lang, 'message_send_error'));
      }
    }
    delete moderatorState[modId];
  } else {
    await ctx.reply(getTranslation(lang, 'unknown_command'));
  }
});


adminBot.callbackQuery('current_arbitrations', async (ctx) => {
  const lang = detectUserLanguage(ctx);
  await ctx.answerCallbackQuery();
  await ctx.reply(getTranslation(lang, 'arbitration_list'));
});

export const POST = webhookCallback(adminBot, 'std/http');
